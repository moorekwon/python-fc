# 정규표현식

## 정규표현식은 왜 필요한가?

정규표현식(Regular Expressions)

- 줄여서 "정규식"

- 복잡한 문자열을 처리할 때 사용하는 기법
- (파이썬만의 고유 문법이 아니라) 문자열을 처리하는 모든 곳에서 사용

- 코드가 간결해짐
- 찾거나 바꿔야 할 문자열의 규칙이 복잡할수록 정규식의 효용은 더 커짐



## 정규표현식의 기초, 메타 문자

정규식에서 사용하는 메타 문자(meta characters)

- 메타 문자: 원래 그 문자가 가진 뜻이 아닌 특별한 용도로 사용하는 문자
-  . ^ $ * + ? { } [ ] \ | ( ) 
- 정규 표현식에 메타 문자를 사용하면 특별한 의미를 가짐



### 문자 클래스 [ ]

의미: "[ ] 사이의 문자들과 매치"

[ ] 사이에는 어떠한 문자도 들어갈 수 있음

- 주의해야 할 메타 문자: ^
  - 문자 클래스 안에 ^를 사용하면 반대(not)라는 의미
  - `[^0-9]`: 문자

[ ] 안의 두 문자 사이에 하이픈(-) 사용

- 두 문자 사이의 범위(from - to)를 의미
- `[a-zA-Z]`: 알파벳 모두, `[0-9]`: 숫자

자주 사용하는 문자 클래스

- \d
  - 숫자와 매치
  - `[0-9]`와 동일한 표현식
- \D
  - 숫자가 아닌 것과 매치
  - `[^0-9]`와 동일한 표현식
- \s
  - whitespace 문자와 매치
  - `[ \t\n\r\f\v]`와 동일한 표현식 (맨 앞 빈 칸은 공백문자)
- \S
  - whitespace 문자가 아닌 것과 매치
  - `[^ \t\n\r\f\v]`와 동일한 표현식
- \w
  - 문자 + 숫자와 매치
  - `[a-zA-Z0-9_]`와 동일한 표현식
- \W
  - 문자 + 숫자가 아닌 문자와 매치
  - `[^a-zA-Z0-9_]`와 동일한 표현식



### Dot(.)

의미: 줄바꿈 문자인 \n을 제외한 모든 문자와 매치

re.DOTALL 옵션을 주면 \n 문자와도 매치

`a.b` = "a + 모든문자 + b" 

- a, b 문자 사이에 어떤 문자가 들어가도 모두 매치

`a[.]b` = "a + .문자 + b"

- 문자 클래스 [ ] 내 . 메타 문자가 사용되면 "모든문자"가 아닌 문자 . 그대로를 의미 



### 반복(*)

`ca*t`

- `*` 바로 앞에 있는 문자 a가 0부터 무한대로 반복될 수 있다는 의미 
- 반복 횟수 0부터

- 'ct', 'cat', 'caaat' 문자열 모두 매치



### 반복(+)

`ca+t` = "c + a(1번 이상 반복) + t"

- 반복 횟수 1부터
- 'ct' 문자열은 매치 x



### 반복({m,n}, ?)

반복 횟수를 제한

{ } 메타 문자를 사용하면 반복 횟수를 고정할 수 있음

{m,n} 정규식

- 반복 횟수가 m부터 n까지 매치
- m 또는 n 생략 가능
  - {m,}: 반복 횟수가 m 이상, 생략된 n은 무한대와 동일(`{1,}` = +, `{0,}` = *)
  - {,n}: 반복 횟수가 n 이하, 생략된 m은 0과 동일

- *, +, ? 메타 문자 모두 {m,n} 형태로 고쳐 쓸 수 있음
- 가급적 이해하기 쉽고 표현이 간결한 *, +, ? 메타 문자 사용을 권장



{m}

- `ca{2}t` = "c + a(반드시 2번 반복) + t"
  - 'cat' 문자열 매치 x

{m,n}

- `ca{2,5}t` = "c + a(2~5회 반복) + t"
  - 'cat' 문자열 매치 x

?

- 반복은 아니지만 비슷한 개념

- `{0,1}`을 의미

- `ab?C` = "a + b(있어도 되고 없어도 됨) + c"

  - b 문자가 있거나 없거나 둘 다 매치

  - 'abc', 'ac' 문자열 모두 매치



## 파이썬에서 정규표현식을 지원하는 re 모듈

re(regular expression) 모듈

- 파이썬이 정규표현식을 지원하기 위해 제공

- 파이썬 설치할 때 자동으로 설치되는 기본 라이브러리

- 사용방법

  ```python
  import re
  # 정규표현식(ab*)을 컴파일
  # re.compile의 결과로 돌려주는 객체 p(컴파일된 패턴 객체) 사용
  # 그 이후의 작업을 수행
  p = re.compile('ab*')
  ```

  - 정규식을 컴파일할 때 특정 옵션을 주는 것도 가능
  - 패턴: 정규식을 컴파일한 결과



## 정규식을 이용한 문자열 검색

컴파일된 패턴 객체가 제공하는 메소드

- match(): 문자열의 처음부터 정규식과 매치되는지 조사
  - 매치되면 match 객체, 매치되지 않으면 None을 돌려줌
- search(): 문자열 전체를 검색해 정규식과 매치되는지 조사
  - 매치되면 match 객체, 매치되지 않으면 None을 돌려줌
- findall(): 정규식과 매치되는 모든 문자열(substring)을 리스트로 돌려줌
- finditer(): 정규식과 매치되는 모든 문자열을 반복 가능한 객체로 돌려줌



match 객체

- 정규식의 검색 결과로 돌려주는 객체



### match

문자열의 <u>처음부터</u> 정규식과 매치되는지 조사

```python
# 패턴 형성
import re
p = re.compile('[a-z]+')
```

```python
m = p.match("python")
# "python" 문자열은 [a-z]+ 정규식에 부합
# match 객체를 돌려줌
print(m) # <_sre.SRE_Match object at 0x01F3F9F8>
```

```python
m = p.match("3 python")
# 처음에 나오는 문자 3이 부합되지 않음
# None을 돌려줌
print(m) # None
```

```python
# match의 결괏값이 있을 경우에만 그 다음 작업을 수행
p = re.compile(정규표현식)
m = p.match( 'string goes here' )
if m:
    print('Match found: ', m.group())
else:
    print('No match')
```



### search

```python
# 패턴 형성
import re
p = re.compile('[a-z]+')
```

```python
m = p.search("python")
# match 메소드를 수행했을 때와 동일하게 매치
print(m) # <_sre.SRE_Match object at 0x01F3FA68>
```

```python
m = p.search("3 python")
# 문자열의 처음부터 검색하는 것이 아니라 문자열 전체를 검색하기 때문에 "python" 문자열과 매치
print(m) # <_sre.SRE_Match object at 0x01F3FA30>
```



### findall

```python
# 패턴 형성
import re
p = re.compile('[a-z]+')
```

```python
result = p.findall("life is too short")
# 'life', 'is', 'too', 'short' 단어를 각각 정규식과 매치해서 리스트로 돌려줌
print(result) # ['life', 'is', 'too', 'short']
```



### finditer

```python
# 패턴 형성
import re
p = re.compile('[a-z]+')
```

```python
result = p.finditer("life is too short")
print(result) # <callable_iterator object at 0x01F5E390>

# findall과 동일하지만 그 결과로 반복 가능한 객체(iterator object)를 돌려줌
# 반복 가능한 객체가 포함하는 각각의 요소는 match 객체
for r in result: print(r)
# ...
# <_sre.SRE_Match object at 0x01F3F9F8>
# <_sre.SRE_Match object at 0x01F3FAD8>
# <_sre.SRE_Match object at 0x01F3FAA0>
# <_sre.SRE_Match object at 0x01F3F9F8>
```



## match 객체의 메소드

 match 객체

- match 메소드와 search 메소드를 수행한 결과로 돌려줌

match 객체의 메소드

- group(): 매치된 문자열을 돌려줌
- start(): 매치된 문자열의 시작 위치를 돌려줌
  - match 메소드를 수행한 결과로 돌려준 match 객체의 start() 결괏값은 항상 0
  - match 메소드는 항상 문자열의 시작부터 조사하기 때문
- end(): 매치된 문자열의 끝 위치를 돌려줌
- span(): 매치된 문자열의 (시작, 끝)에 해당하는 튜플을 돌려줌

```python
m = p.match("python")
m.group() # 'python'
m.start() # 0
m.end() # 6
m.span() # (0, 6)
```

```python
m = p.search("python")
m.group() # 'python'
m.start() # 2
m.end() # 8
m.span() # (2, 8)
```



모듈 단위로 수행

- re.compile을 사용해 컴파일된 패턴 객체로 그 이후의 작업 수행

  ```python
  p = re.compile('[a-z]+')
  m = p.match("python")
  ```

  - 한 번 만든 패턴 객체를 여러 번 사용해야 할 때

- re 모듈은 축약한 형태로 사용할 수 있는 방법을 제공

  ```python
  m = re.match('[a-z]+', "python")
  ```

  - 컴파일과 match 메소드를 한 번에 수행



## 컴파일 옵션

전체 옵션 이름(ex. re.DOTALL)을 써도 되고 약어(ex. re.S)를 써도 됨

1. DOTALL(S)
   - .이 (줄바꿈 문자 포함) 모든 문자와 매치하도록 함

2. IGNORECASE(I)
   - 대소문자 관계 없이 매치하도록 함

3. MULTILINE(M)
   - 여러 줄과 매치하도록 함
   - ^, $ 메타 문자의 사용과 관계 있는 옵션

4. VERBOSE(X)
   - verbose 모드를 사용하도록 함
   - 정규식을 보기 편하게 만들고, 주석 등을 사용할 수 있음



<!--'DOTALL, S' ~ 'MULTILINE, M' 추후 정리-->

### DOTALL, S

### IGNORECASE, I

### MULTILINE, M



### VERBOSE, X

이해하기 어려운 정규식을 주석 또는 줄 단위로 구분

보기 좋고 이해하기 쉽도록 함

re.VERBOSE 또는 re.X

```python
# 컴파일된 패턴 객체 charref
charref = re.compile(r'&[#](0[0-7]+|[0-9]+|x[0-9a-fA-F]+);')
```

```python
# 주석을 적고, 여러 줄로 표현하여 가독성 높임
charref = re.compile(r"""
&[#]
(
	0[0-7]+ # octal
	|[0-9]+ # decimal
	|x[0-9a-fA-F]+ # hexadecimal
)
;
""", re.VERBOSE)
```

- 문자열에 사용된 whitespace는 컴파일 할 때 제거됨
  - [ ] 안에 사용한 whitespace는 제외
- 줄 단위로 # 기호를 사용해 주석문 작성 가능



## 백슬래시 문제

```python
# 어떤 파일 안에 있는 "\section" 문자열을 찾기 위한 정규식을 만듦
\section
```

- \s 문자가 whitespace로 해석되어 의도한대로 매치가 이루어지지 않음
- `[ \t\n\r\f\v]ection`과 동일한 의미



```python
# 위 정규식을 컴파일
p = re.compile('\\section')
```

- \ 문자가 문자열 자체임을 알려 주기 위해 백슬래시 2개를 사용해 이스케이프 처리
- 실제 파이썬 정규식 엔진에는 파이썬 문자열 리터럴 규칙에 따라 `\\`이 `\`로 변경



```python
p = re.compile('\\\\section')
```

- 정규식 엔진(모듈)에 `\\` 문자를 전달하기 위해 `\\\\`로 백슬래시 4개 사용
- 원하는 결과는 얻으나 너무 복잡해서 이해하기 쉽지 않음



```python
# Raw String 규칙
p = re.compile(r'\\section')
```

- 컴파일해야 하는 정규식이 Raw String임을 알려주는 파이썬 문법
- 정규식 문자열 앞에 r 문자를 삽입
- 백슬래시 2개 대신 1개만 써도 2개를 쓴 것과 동일한 의미



[점프 투 파이썬/ 07장 정규표현식/ 07-3 강력한 정규 표현식의 세계로](https://wikidocs.net/4309)

## 메타 문자

### |

### ^

### $

### \A

### \Z

### \b

### \B



## 그루핑

### 그루핑된 문자열 재참조하기

### 그루핑된 문자열에 이름 붙이기



## 전방 탐색

### 긍정형 전방 탐색

### 부정형 전방 탐색



## 문자열 바꾸기

### sub 메소드 사용 시 참조 구문 사용하기

### sub 메소드의 매개변수로 함수 넣기



## Greedy vs Non-Greedy

