# 운영체제

###### 사용자(user)

###### 응용 프로그램(Application)

- 사용자 프로그램
- 개발 시 운영체제 기능이 필요한 경우, 해당 운영체제의 API를 사용하여 프로그램 작성
- CPU 외 다양한 하드웨어를 사용 (-> **멀티 프로그래밍**과 관련)
- 실행 시 해당 API를 호출
  - 시스템 콜 호출, **커널 모드**로 변경
  - 운영체제 내부에서 해당 명령이 실행되고, 응용 프로그램에 결과를 리턴

###### 운영체제(OS, Operating System)

- 주요 운영체제: 윈도우, 리눅스/UNIX, MacOS
- 프로세스 관리, 주기억장치 관리, 파일 관리, 디스크 관리, 입출력 관리, 네트워킹 및 보호/보안
- 사용자 인터페이스(**쉘,** Shell)를 제공
  - 쉘
    - 사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 프로그램
    - CLI(터미널) 환경과 GUI 환경으로 분류
- 응용 프로그램 인터페이스(**시스템 콜**, System Call)를 제공
  - 시스템 콜 (또는 시스템 호출 인터페이스)
    - 운영체제가 운영체제의 각 기능을 사용하도록 명령 또는 함수를 제공
    - API 내부에는 시스템 콜을 호출하는 형태로 만들어지는 경우가 대부분
    - 커널 모드로 실행
- 프로그래밍 언어별 운영체제 지원을 위해, 운영체제 별 **API** 제공

###### 컴퓨터 하드웨어(Hardware)



## CPU Protection Ring

###### 사용자 모드(user mode)

- 응용 프로그램이 사용

###### 커널 모드(kernel mode)

- 함부로 응용 프로그램이 전체 컴퓨터 시스템을 헤치지 못함

- 운영체제가 사용
- 커널 모드로 실행하려면, 반드시 (운영체제가 제공하는) 시스템 콜을 거쳐야 함



## 프로세스(Process) vs 스레드(Thread)

|         프로세스         |        스레드        |
| :----------------------: | :------------------: |
|          독립적          |  프로세스의 서브셋   |
|   독립적인 자원을 가짐   | 프로세스 자원을 공유 |
| 자신만의 주소영역을 가짐 |   주소영역을 공유    |
|    IPC 기법으로 통신     |  IPC 기법 필요 없음  |



## 프로세스(Process)

(메모리에 올려져서) 실행 중인 프로그램

응용 프로그램은 여러 프로세스로 구성 가능

작업, task, job 용어와 혼용

코드 이미지(바이너리 코드): 실행 파일프로세스(Process) vs 스레드(Thread)



###### 프로세스와 컴퓨터 구조: **PC + SP**

- PC(Program Coutner): 다음 실행할 코드 주소(실행 코드 라인)
- SP(Stack Pointer): 스택 최상단 주소(위치)

- 리눅스의 프로세스
  - 커널 공간은 공유
  - 어떤 프로세스나 0~4GB까지의 메모리 주소를 가짐



## 프로세스 간 통신

프로세스 간에는 각 프로세스의 데이터 접근 불가

여러 프로세스를 만들어 동시에 실행하기 위해 프로세스 간 상태 확인 및 데이터 송수신이 필요

여러 프로세스의 동시 실행을 통한 성능 개선과 복잡한 프로그램을 위해 필요



###### **IPC(InterProcess Communication)**

- 프로세스 간 공간이 분리되어  있어, 통신을 위한 특별한 기법이 필요

- 프로세스 간 통신 방법을 제공

- IPC 기법

  - file 사용: 실시간으로 직접 원하는 프로세스에 데이터를 전달하는 것이 어려움

  - 대부분의 경우, **커널 공간을 활용**(공유)

    - Shared Memory(공유 메모리): 커널 공간에 메모리 공간을 만들어 해당 공간을 변수처럼 씀

    - Message Queue, Pipe, Signal, Semaphore, Socket, ...



## 프로세스 스케쥴링

###### 배치 처리 시스템

- 여러 프로그램을 순차적으로 실행
- 어떤 프로그램의 실행 시간이 많이 걸리면, 다른 프로그램이 실행하는데 시간을 많이 기다려야 함
- 교착상태(deadlock)가 일어나지 않음



###### 시분할 시스템

- (여러 사용자가 동시에 하나의 컴퓨터를 쓰도록) 다중 사용자 지원
- 컴퓨터 응답 시간을 최소화



###### 멀티 태스킹

- **단일 CPU**에서 여러 응용 프로그램을 동시에 실행하는 것처럼 보이도록 함
- 10~30ms 단위로도 실행 응용 프로그램이 바뀜
- MP3 음악을 들으면서 문서 작성하기, 등



###### 멀티 프로그래밍

- 최대한 CPU를 (일정시간당) 많이 활용하도록 함
- Wait: 간단히 저장매체로부터 파일 읽기를 기다리는 시간으로 가정



###### 멀티 프로세싱

- **여러 CPU**에 하나의 응용 프로그램을 병렬로 실행하여 실행 속도를 극대화
- 처음 구조를 잡을 때 만들어야 함
- 인스턴스 간, 공유된 자원 간의 읽고 쓰기가 빈번한 경우 사용하기에 적합



## 프로세스 상태

running: 현재 CPU에서 **실행** 상태

ready: CPU에서 실행 **가능** 상태 (실행 대기 상태)

block: 특정 이벤트 발생 **대기** 상태



###### 프로세스 상태 간 관계

1. running->block: 입력을 위해 프로세스 대기
2. ready->running: 스케쥴러가 다른 프로세스를 찍음
3. running->ready: 스케쥴러가 이 프로세스를 찍음
4. block->ready: 프로세스가 실행 가능해짐



## 프로세스 구조

stack: 임시 데이터(함수 호출, 로컬 변수 등)

heap: 코드에서 동적으로 만들어지는 데이터

data: 변수/초기화된 데이터

text(CODE): 코드



## 컨텍스트 스위칭(Context Switching, 또는 문맥 교환)

CPU에 실행할 **프로세스를 교체**하는 기술

PC, SP만 바꿔주면 프로세스 저장 상태를 기반으로 실행 가능

실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트하여 **메인 메모리에 저장**

다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB 정보(PC, SP)를 CPU의 레지스터에 넣고 실행(**메인 메모리에서 로드**)



## PCB(Process Control Block)

PCB에 다음 프로세스 정보(Process ID, Register, 등)를 저장

프로세스가 실행 중인 상태를 캡쳐/구조화하여 저장



## 스레드(Thread)

Light Weight Process

하나의 프로세스에 여러 개의 스레드 생성 가능

여러 스레드를 동시에 실행 가능하며, 각기 실행 가능한 stack이 존재



###### 장점

- CPU 활용도를 높이고, 성능 개선 가능
- 사용자에 대한 응답성 향상
- 자원 공유의 효율성
  - 스레드 간 자원 공유가 가능하기 때문에, IPC를 쓰지 않아도 됨
  - 프로세스 안에 있기 때문에, 프로세스의 데이터를 모두 접근 가능
- 작업이 분리되어 코드가 간결해질 수 있음

###### 단점

- (프로세스와 달리) 스레드 중 한 스레드만 문제가 있어도 전체 프로세스가 영향을 받음

- 많이 생성하면 컨텍스트 스위칭이 많이 일어나 성능 저하

  - 리눅스 운영체제의 경우
    - 스레드를 프로세스와 같이 다룸
    - 모든 스레드를 스케쥴링해야 하므로, 컨텍스트 스위칭이 빈번할 수밖에 없음

- **동기화(Synchronization)** 이슈

  - 동기화: 작업들 사이에 실행 시기를 맞추는 것

  - 여러 스레드가 동일한 자원(데이터)을 접근할 시, 비정상적으로 동작할 수 있음

  - 여러 스레드가 동일한 자원을 동시에 수정할 시, 각 스레드 결과에 영향을 줌

  - 해결 방안: **상호 배제**(Mutual exclusion)

    - 동기화 코드를 적절히 추가

    - 프로세스의 모든 데이터를 접근할 수 있기 때문에, 여러 스레드가 변경하는 공유 변수에 대해 Exclusive access 필요
    - 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시에 접근하지 못하도록 막음
    - 임계 자원(critical resource)과 임계 구역(critical section)

  - 임계 구역에 대한 접근을 막기 위한 LOCKING 매커니즘

    - **Semaphore**(세마포어)
      - 임계구역에 여러 스레드가 들어갈 수 있음
      - counter을 두어 동시에 리소스에 접근할 수 있는 허용 가능한 스레드 수를 제어
    - Mutex(binary semaphore)
      - 임계구역에 하나의 스레드만 들어갈 수 있음



###### 교착상태(deadlock)

- 무한 대기 상태
- 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있어 다음 단계로 진행하지 못하는 상태
- 프로세스, 스레드 모두 일어날 수 있음
- 여러 프로세스가 동일한 자원의 점유를 요청할 때 발생
- 발생 조건
  - 상호 배제(Mutual exclusion): 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구
  - 점유 대기(Hold and wait): 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림
  - 비선점(No preemption): 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없음
  - 순환 대기(Circular wait): 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있음

###### 기아상태(starvation)

- 특정 프로세스의 우선순위가 낮아 원하는 자원을 계속 할당받지 못하는 상태
- 여러 프로세스가 부족한 자원의 점유를 위해 경쟁할 때, 특정 프로세스는 영원히 자원 할당이 안되는 상태
- 해결 방안: 우선순위 변경
  - 프로세스 우선순위를 수시로 변경
  - 각 프로세스가 높은 우선순위를 가질 기회를 줌
  - 오래 기다린 프로세스의 우선순위를 높여줌
  - 우선순위가 아닌, 요청 순서대로 처리하는 FIFO 기반 요청큐 사용



## 멀티 스레드(Multi Thread)

소프트웨어의 병행 작업 처리를 위해 사용 (Code 영역 공유)

스레드 간 자원 공유 가능

스레드 간 별도의 통신 오버헤드가 적음

공유된 자원 간 읽고 쓰기가 빈번할 경우, 추가적인 오버헤드가 드는 동기화 기법을 사용해야 함

공유된 자원 간 쓰기가 없는 경우 사용하기에 적합

- 동기화 기법을 적용할 필요가 없음

최근 CPU는 멀티 코어를 가지므로, 스레드를 여러 개 만들어 멀티 코어의 활용도를 높임

프로그램의 일부 동작에서만 사용하도록 일부 코드를 수정함으로써 만들 수 있음